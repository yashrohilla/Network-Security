# Network-Security


Demonstration of how weak WEP is:
WEP uses RC4 algorithm which was incorrectly implemented and allows attackers to modify messages without needing the secret key to view the message. The rcv_msg.py file is a user who generates the secret key, creates a keystream using rc4.py and send the message to rcv_msg.py. Message_Mod.py sniffs the network for messages and without knowledge of the secret key/keystream performs an XOR operation with the cipher text and a new message that the attacker generates. Rcv_msg.py receives two messages, one from the genuine user and another from Message_Mod.py. Both appear to have been generated using the secret key and hence seem valid and from the same user.


Port-Coding:
Port-Coding is a form of Network Steganography. It is a technique where the sender and receiver agree on a set of ports where each port represents a value from the hexadecimal representation space. When some data is received on a certain port, it is understood as a value from the hexadecimal set. Adrian Ho invented this technique to encode hidden data in a network transmission. According to the Internet Assigned Numbers Authority (IANA), ports 0-1023 are reserved and called System Ports. Ports ranging from 1024-49151 are called User Ports and are to be assigned by the IANA after the IETF Review process. Finally, the port range 49152-65535 is called the Dynamic Ports range. These ports are not reserved and cannot be associated with a protocol. The port-coding process cannot utilize any ports that have already been reserved. In this paper, we will use port range 32000 to 32015. 
    
A receiver would listen to the set of 16 or 17 ports that have been agreed on before hand with the sender. In real world scenario, the port range would be scrambled so that it is not as easy for someone to decode the message. Each port is assigned a specific value in the hexadecimal set. For simplicity, we will serially assign values to the 16 ports that we chose. Port 32000 will be assigned '0', port 32001 will be assigned '1' and so on until port 32015 will be assigned 'f'. The sender will simply look up the port number that is assigned to the specific hexadecimal value and can send any nonsensical data in the payload. It might be in the interest of the sender to send something meaningful but not valuable in the payload in order to obfuscate anyone monitoring the medium. Once the receiver gets a "message" on the agreed upon ports, they will simply decode the message. 
    
Adrian Ho invented this technique with Transmission Control Protocol (TCP) in mind. This would take care of any duplicate transmissions or dropped packets. Since we are on the local network and have a very high probability that there will not be any packet-loss, we decided to implement this technique using User Datagram Protocol (UDP). UDP is termed a connection-less protocol because, unlike TCP, it does not establish a three-way handshake prior to sending any data. In the UDP header there are only 4 fields; source port, destination port, length and checksum. 
    
In my implementation of the port-coding mechanism of Steganography, I used the Scapy library in Python to send crafted packets. The short program asks the user to input a secret message. This secret message is encoded to hexadecimal format using encode('hex'). Then we run a for loop through the hex message that we are sending. Depending on the character about to be "sent", we choose the port and transmit over it.
